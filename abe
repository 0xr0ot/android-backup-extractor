#!/bin/sh

# honor JAVA environment variable if set; if not, use JAVA_HOME (if it's set);
# if not, fall back to the old hardcoded default.
: "${JAVA:=${JAVA_HOME:-/usr/local/jdk1.7.0_51}/bin/java}"

# Follow symlinks, if we have readlink available; this will allow a symlink to
# the real wrapper script's location to be installed somewhere on the PATH (ie.
# /usr/local/bin/abe, or $HOME/bin/abe).
#
# This technique has flaws. See http://mywiki.wooledge.org/BashFAQ/028 to
# understand its limitations before reusing it in your own scripts.
executable=$0
if type -P readlink >/dev/null; then
	while target=$(readlink "$executable"); do
		[[ $executable = "$target" ]] && break # avoid endless loops
		executable=$target
	done
fi
basedir=$(dirname "$executable")

cp=$basedir:$basedir/bin:$basedir/abe.jar
for f in $basedir/lib/*.jar; do
	# note that this technique only works as long as nullglob is disabled
	# (which it is, by default, on all POSIX shells); we're relying on the
	# *.jar glob expression returning literally '*.jar' as a result when no
	# matches exist on-disk.
	[[ -e $f ]] || {
		echo "WARNING: No jars found in lib directory. Please download a BouncyCastle implementation per the README (looking for: $f)" >&2
		continue
	}
	cp=$cp:$f
done

[[ -e $basedir/abe.jar ]] || {
	echo "ERROR: Could not find abe.jar in $basedir; did you run ant to compile?" >&2
	exit 1
}

[[ -e $JAVA ]] || {
	echo "ERROR: Could not find java executable at $JAVA" >&2
	exit 1
}

# Using "exec" here replaces the script's process table entry with that of the
# JVM, avoiding the need to keep the script in memory while the executable
# runs.
exec "$JAVA" -cp "$cp" org.nick.abe.Main "$@"
